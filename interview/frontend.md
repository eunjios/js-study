# 📖 프론트엔드 질문 정리
- [브라우저](#브라우저)
    - [1. 브라우저는 어떻게 동작하나요?](#1-브라우저는-어떻게-동작하나요)
    - [2. 브라우저 렌더링 과정을 설명해 주세요.](#2-브라우저-렌더링-과정을-설명해-주세요)
    - [3. Webpack, Babel, Polyfill에 대해 설명해 주세요.](#3-webpack-babel-polyfill에-대해-설명해-주세요)
    - [4. CSR과 SSR의 차이점은?](#4-csr과-ssr의-차이점은)
- [인증](#인증)
    - [1. JWT 인증 방식과 세션 방식의 차이점은?](#1-jwt-인증-방식과-세션-방식의-차이점은)
    - [2. JWT 인증 방식의 장점은?](#2-jwt-인증-방식의-장점은)
    - [3. 쿠키, 세션, 웹 스토리지의 차이는?](#3-쿠키-세션-웹-스토리지의-차이는)
    - [4. 로그인 전의 장바구니가 로그인 후에도 유지되려면 어떻게 할까?](#4-로그인-전의-장바구니가-로그인-후에도-유지되려면-어떻게-할까)

## 브라우저 
### 1. 브라우저는 어떻게 동작하나요?
> URL이 입력되었을 때 어떻게 페이지를 보여주는 것인가?  
> 참고자료: [브라우저는 어떻게 동작하는가](https://d2.naver.com/helloworld/59361)
- 브라우저 검색창에 URL을 작성 후 엔터 버튼을 누르면, 해당 URL을 IP 주소로 변환하고 요청을 보낼 서버를 결정한다.
- 브라우저는 웹서버에 HTTP 요청을 보내서 필요한 자원을 요청한다.
    - HTML 문서, 이미지, 스타일 시트, 스크립트 등의 자원을 요청
    - 브라우저와 웹서버는 TCP/IP 프로토콜 사용
- 브라우저의 렌더링 엔진은 웹서버에서 받은 자원들을 해석한다.
- 우선 브라우저의 HTML 파서는 HTML 문서를 파싱하고 구조를 파악하면서 DOM 트리를 만든다.
- 그 다음 CSS 정보를 스타일 구조체로 만든다.
- DOM 트리와 스타일 구조체를 결합하여 렌더 트리를 만든다.
    - **렌더 트리**: 실제 화면에 표시될 요소
- 브라우저는 렌더 트리 각 요소에 대한 크기와 위치를 계산하여 페이지의 레이아웃을 정한다.
- UI 백엔드가 화면에 각 요소를 그린다. 
    - 텍스트, 이미지, 배경 색깔 등 포함
    - 이 과정은 자원을 받고 기다리는 동시에 같이 이루어진다. (마치 비동기처럼) 페이지 일부만 먼저 보이는 것이 이러한 이유 때문이다.

### 2. 브라우저 렌더링 과정을 설명해 주세요.
- 브라우저의 렌더링 엔진은 가장 먼저 HTML 문서를 파싱한다. 문서를 파싱하여 문서의 구조를 이해한 다음 문서 객체 모델 (DOM)을 만든다.
- 다음으로 CSS도 파싱한다. 파싱한 CSS를 해석하여 각 요소에 필요한 스타일을 계산하고, DOM과 결합하여 렌더 트리 구조를 만든다.
- 브라우저는 각 요소가 배치될 위치와 크기를 결정한다.
- 이후 컨텐츠를 픽셀 단위로 그리면서 렌더링이 완료된다.
- 참고로 이 과정은 서버 응답을 기다리면서 동시에 진행된다. 그래서 페이지 일부만 렌더링 될 수 있는 것이다.

### 3. Webpack, Babel, Polyfill에 대해 설명해 주세요.
**Webpack**
- 웹팩은 배포하기 전에 번들링 하는 도구다. 소스코드를 모듈별로 분리해서 개발을 한 후, 배포할 때는 dist 디렉토리에 번들링을 하고 그 파일만 배포를 하는 것이다. 즉, src 내부를 배포할 필요 없이 dist 폴더 에 번들링을 한 후, dist 파일만 배포하면 된다. 
    - 번들링? 개발 시 여러 파일로 나눠서 개발하고, 배포 시 하나로 묶어서 배포하는 것
    - 모듈 번들러? 번들링을 하는 도구
    - 왜 번들링이 필요? HTTP 요청을 줄여서 사용자 경험 향상 

**Babel**
- 바벨은 최신 ESNext 문법을 이전 문법으로 바꿔주는 트랜스 파일러다. 주로 웹팩과 같은 번들러와 함께 사용된다.

**Polyfill**
- 폴리필은 특정 기능이 지원되지 않는 브라우저를 위해 해당 기능을 사용할 수 있도록 하는 코드 조각이나 플러그인이다. 즉, 크로스브라우징 문제를 해결해 주는 기술이다.

### 4. CSR과 SSR의 차이점은?
- CSR(클라이언트 사이드 렌더링)과 SSR(서버 사이드 렌더링)은 렌더링 위치에 차이가 있다.

**CSR (Client Side Rendering)**
- 서버로부터 **초기 HTML과 빈 페이지**를 받는다.
- 브라우저는 이 초기 페이지를 자바스크립트를 사용하여 동적으로 렌더링 한다.
- 초기 페이지 로딩은 빠르다.
- 초기 HTML이 비어있을 수 있어서 별도의 SEO 최적화 처리를 해야할 수 있다.
- 서버 부하가 상대적으로 낮다.

**SSR (Server Side Rendering)**
- 서버에서 초기 렌더링 진행 후 브라우저로 전송한다.
- 브라우저는 이 HTML을 받고 자바스크립트 실행 없이 렌더링한다.
- 초기 페이지 로딩은 느리지만, 이후 로딩 속도는 빠르다.
- SEO에 유리하다.
- 서버 부하가 높을 수 있고, 동시 접속이 많을 경우 서버 성능에 영향을 미칠 수 있다.

## 인증
### 1. JWT 인증 방식과 세션 방식의 차이점은?
- 토큰 또는 세션을 어디에 저장하는지에 차이가 있다.
- JWT 방식은 토큰을 클라이언트 측에 저장한다. 서버에서는 토큰을 생성하거나, 해석하는 역할만 맡는다. 클라이언트는 토큰을 HTTP 헤더에 포함시켜 인증을 진행한다.
- 쿠키 세션 방식은 토큰을 서버에 저장한다. 서버에서 세션을 생성하고, 저장 후 삭제하는 역할을 모두 맡는다. 클라이언트는 서버에서 생성된 세션 id를 제공받아 withCredentials을 true로 설정하여 인증을 진행한다.

### 2. JWT 인증 방식의 장점은?
- JWT는 Token에 이미 정보가 포함되어 있기 때문에 DB에서 유저 정보를 가져오지 않아도 된다.
    - JWT는 헤더, 페이로드, 서명으로 구성되어 있다.
    - 헤더: 토큰 타입, 암호화 알고리즘 등
    - 페이로드: 사용자 아이디, 이름, 관리자 여부 등
    - 서명: 서버의 비밀키 (무결성 보장)
- 토큰을 클라이언트에 저장하기 때문에 서버를 여러 개로 가질 수 있다.

**🤔 어떻게 한 사용자를 여러 서버에서 인증할 수 있을까?**
- 서버가 달라도 동일한 비밀키를 공유하면 된다.
- 그러나 보안 문제가 있을 수 있기 때문에 **공개키 암호화(Public Key Cryptography) 기법**을 사용하면 된다.
- 각각의 서버는 개인키(Private Key)를 생성하고, 다른 모든 서버에게 자신의 공개키(Public Key)을 제공한다. 다른 서버들은 이 공개키로 JWT를 검증할 수 있다.

### 3. 쿠키, 세션, 웹 스토리지의 차이는?
> 참고자료: [브라우저 저장소 (Web Storage, Cookie, Session) 그리고 Cache](https://velog.io/@hoon0123/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A0%80%EC%9E%A5%EC%86%8CWeb-Storage-Cookie-session-%EA%B7%B8%EB%A6%AC%EA%B3%A0-cache)



- HTTP는 상태가 없는 프로토콜이기 때문에 통신이 끝나면 상태 정보가 유지되지 않는다. 즉, 페이지를 이동하면 기존 상태가 유지되지 않는다. 따라서 페이지를 이동해도 그 상태가 유지되게 하기 위해서 (유저 구분 등) 브라우저 저장소를 사용한다.

**쿠키**
- 웹 브라우저에 저장되는 작은 데이터 조각으로 클라이언트 측에 저장된다. 따라서 브라우저를 닫아도 쿠키는 보존된다.
- 브라우저마다, 웹사이트 마다 구분된다.
- 동작 방식
    1. 클라이언트가 페이지를 요청
    2. 서버에서 쿠키 생성 후 HTTP Response 헤더의 Set-Cookie 속성에 쿠키를 포함시켜 응답
    3. 클라이언트에서 해당 쿠키를 로컬에 저장
    4. 요청을 서버에 보낼 때 헤더에 쿠키를 포함
    5. 서버는 받은 쿠키에 해당하는 응답을 전송
- 예시
    - 사용자 세션 관리: `sessionId=1`, `userId=eunji` 
    - 사용자 환경 설정: `theme=black`, `language=ko`
    - 장바구니 정보: `cart=[{"prodId": 1, "count": 2}, {"prodId": 23, "count": 1}]`

**세션**
- 웹 브라우저의 상태를 서버 측에서 관리한다.
- 클라이언트에는 해당 세션 ID만 저장하고, 실제 데이터는 서버에 저장한다.
- 동작 방식
    1. 클라이언트가 페이지를 요청
    2. 서버에서 세션 생성
    3. 클라이언트에서 세션 아이디를 받아서 쿠키로 로컬에 저장
    4. 요청을 서버에 보낼 때 이 쿠키의 세션 아이디를 함께 전송
    5. 서버는 받은 세션 아이디에 해당하는 응답을 전송
- 예시
    ```json
    {
        "sessionId": "abc12345",
        "userId": 123,
        "cartItems": [
            { "productID": 123, "quantity": 2 },
            { "productID": 456, "quantity": 1 }
        ],
        "userRole": "customer",
        "language": "en",
        "sessionTimeout": "1800"
    }
    ```

**웹 스토리지**
- 굳이 서버에 전송하지 않아도 되는 데이터를 클라이언트에 저장할 수 있도록 하는 저장소 (cf. 쿠키의 경우 헤더에 포함시켜야 함)
- 네트워크 트래픽을 줄여준다는 장점이 있다.
- 쿠키에 비해 더 큰 용량을 저장할 수 있으며, 도메인 제한 때문에 보안이 더 낫다.
- 종류
    - LocalStorage
        - 명시적으로 제거하지 않는 이상 영구적으로 보관 가능
        - 도메인마다 LocalStorage 생성하여 도메인이 같으면 동일한 로컬 스토리지를 사용함
    - SessionStorage
        - 윈도우나 브라우저 탭을 닫을 경우 제거됨 

### 4. 로그인 전의 장바구니가 로그인 후에도 유지되려면 어떻게 할까? 
> 👀 어떤 사이트는 장바구니가 유지되고, 어떤 사이트는 유지되지 않길래 궁금해서 찾아봤다. 
- 장바구니 유지
    - 로그인 하지 않은 상태에서의 장바구니를 서버의 세션에 저장하면 된다. 로그인 상태와 관계 없이 세션 ID가 유지되기 때문에 기존의 장바구니 상태가 유지될 수 있다.
- 장바구니 비유지
    - 로그인 한 경우와 로그인 하지 않은 경우를 분리하여 저장하면 장바구니가 유지되지 않는다. 로그인 한 경우는 장바구니가 서버에 저장되지만 로그인 하지 않은 경우는 장바구니 상태를 서버가 아닌 클라이언트에 쿠키나 로컬 스토리지에 저장한다.