# 📖 프론트엔드 질문 정리

## 브라우저 
### 1. 브라우저는 어떻게 동작하나요?
> URL이 입력되었을 때 어떻게 페이지를 보여주는 것인가?  
> 참고자료: [브라우저는 어떻게 동작하는가](https://d2.naver.com/helloworld/59361)
- 브라우저 검색창에 URL을 작성 후 엔터 버튼을 누르면, 해당 URL을 IP 주소로 변환하고 요청을 보낼 서버를 결정한다.
- 브라우저는 웹서버에 HTTP 요청을 보내서 필요한 자원을 요청한다.
    - HTML 문서, 이미지, 스타일 시트, 스크립트 등의 자원을 요청
    - 브라우저와 웹서버는 TCP/IP 프로토콜 사용
- 브라우저의 렌더링 엔진은 웹서버에서 받은 자원들을 해석한다.
- 우선 브라우저의 HTML 파서는 HTML 문서를 파싱하고 구조를 파악하면서 DOM 트리를 만든다.
- 그 다음 CSS 정보를 스타일 구조체로 만든다.
- DOM 트리와 스타일 구조체를 결합하여 렌더 트리를 만든다.
    - **렌더 트리**: 실제 화면에 표시될 요소
- 브라우저는 렌더 트리 각 요소에 대한 크기와 위치를 계산하여 페이지의 레이아웃을 정한다.
- UI 백엔드가 화면에 각 요소를 그린다. 
    - 텍스트, 이미지, 배경 색깔 등 포함
    - 이 과정은 자원을 받고 기다리는 동시에 같이 이루어진다. (마치 비동기처럼) 페이지 일부만 먼저 보이는 것이 이러한 이유 때문이다.

## 인증
### 1. JWT 인증 방식과 세션 방식의 차이점은?
- 토큰 또는 세션을 어디에 저장하는지에 차이가 있다.
- JWT 방식은 토큰을 클라이언트 측에 저장한다. 서버에서는 토큰을 생성하거나, 해석하는 역할만 맡는다. 클라이언트는 토큰을 HTTP 헤더에 포함시켜 인증을 진행한다.
- 쿠키 세션 방식은 토큰을 서버에 저장한다. 서버에서 세션을 생성하고, 저장 후 삭제하는 역할을 모두 맡는다. 클라이언트는 서버에서 생성된 세션 id를 제공받아 withCredentials을 true로 설정하여 인증을 진행한다.

### 2. JWT 인증 방식의 장점은?
- JWT는 Token에 이미 정보가 포함되어 있기 때문에 DB에서 유저 정보를 가져오지 않아도 된다.
    - JWT는 헤더, 페이로드, 서명으로 구성되어 있다.
    - 헤더: 토큰 타입, 암호화 알고리즘 등
    - 페이로드: 사용자 아이디, 이름, 관리자 여부 등
    - 서명: 서버의 비밀키 (무결성 보장)
- 토큰을 클라이언트에 저장하기 때문에 서버를 여러 개로 가질 수 있다.

**🤔 어떻게 한 사용자를 여러 서버에서 인증할 수 있을까?**
- 서버가 달라도 동일한 비밀키를 공유하면 된다.
- 그러나 보안 문제가 있을 수 있기 때문에 **공개키 암호화(Public Key Cryptography) 기법**을 사용하면 된다.
- 각각의 서버는 개인키(Private Key)를 생성하고, 다른 모든 서버에게 자신의 공개키(Public Key)을 제공한다. 다른 서버들은 이 공개키로 JWT를 검증할 수 있다.

### 3. 쿠키, 세션, 웹 스토리지의 차이는?
> 참고자료: [브라우저 저장소 (Web Storage, Cookie, Session) 그리고 Cache](https://velog.io/@hoon0123/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A0%80%EC%9E%A5%EC%86%8CWeb-Storage-Cookie-session-%EA%B7%B8%EB%A6%AC%EA%B3%A0-cache)



- HTTP는 상태가 없는 프로토콜이기 때문에 통신이 끝나면 상태 정보가 유지되지 않는다. 즉, 페이지를 이동하면 기존 상태가 유지되지 않는다. 따라서 페이지를 이동해도 그 상태가 유지되게 하기 위해서 (유저 구분 등) 브라우저 저장소를 사용한다.

**쿠키**
- 웹 브라우저에 저장되는 작은 데이터 조각으로 클라이언트 측에 저장된다. 따라서 브라우저를 닫아도 쿠키는 보존된다.
- 브라우저마다, 웹사이트 마다 구분된다.
- 동작 방식
    1. 클라이언트가 페이지를 요청
    2. 서버에서 쿠키 생성 후 HTTP Response 헤더의 Set-Cookie 속성에 쿠키를 포함시켜 응답
    3. 클라이언트에서 해당 쿠키를 로컬에 저장
    4. 요청을 서버에 보낼 때 헤더에 쿠키를 포함
    5. 서버는 받은 쿠키에 해당하는 응답을 전송
- 예시
    - 사용자 세션 관리: `sessionId=1`, `userId=eunji` 
    - 사용자 환경 설정: `theme=black`, `language=ko`
    - 장바구니 정보: `cart=[{"prodId": 1, "count": 2}, {"prodId": 23, "count": 1}]`

**세션**
- 웹 브라우저의 상태를 서버 측에서 관리한다.
- 클라이언트에는 해당 세션 ID만 저장하고, 실제 데이터는 서버에 저장한다.
- 동작 방식
    1. 클라이언트가 페이지를 요청
    2. 서버에서 세션 생성
    3. 클라이언트에서 세션 아이디를 받아서 쿠키로 로컬에 저장
    4. 요청을 서버에 보낼 때 이 쿠키의 세션 아이디를 함께 전송
    5. 서버는 받은 세션 아이디에 해당하는 응답을 전송
- 예시
    ```json
    {
        "sessionId": "abc12345",
        "userId": 123,
        "cartItems": [
            { "productID": 123, "quantity": 2 },
            { "productID": 456, "quantity": 1 }
        ],
        "userRole": "customer",
        "language": "en",
        "sessionTimeout": "1800"
    }
    ```

**웹 스토리지**
- 굳이 서버에 전송하지 않아도 되는 데이터를 클라이언트에 저장할 수 있도록 하는 저장소 (cf. 쿠키의 경우 헤더에 포함시켜야 함)
- 네트워크 트래픽을 줄여준다는 장점이 있다.
- 쿠키에 비해 더 큰 용량을 저장할 수 있으며, 도메인 제한 때문에 보안이 더 낫다.
- 종류
    - LocalStorage
        - 명시적으로 제거하지 않는 이상 영구적으로 보관 가능
        - 도메인마다 LocalStorage 생성하여 도메인이 같으면 동일한 로컬 스토리지를 사용함
    - SessionStorage
        - 윈도우나 브라우저 탭을 닫을 경우 제거됨 
